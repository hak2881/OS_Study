## 페이지 교체

### 요구 페이징
> * CPU가 특정 페이지에 접근하는 명령어를 실행 햇을때, 해당 페이지가 스왑 영역에 있어서 당장 실행시킬 수 없는 상태일 경우에는 `'페이지 폴트'` 예외가 발생한다.
> * 페이지 폴트 예외가 발생하면 스와핑 작업이 먼저 진행된 후에 프로세스가 실행된다.
> * 실행할 모든 프로세스를 메모리에 올려두는 것은 시스템에 부담이 될 수 있는 만큼 당장 필요한 페이지만을 메모리에 우선 적재하는 방법을 가리켜 `'요구페이징'` 이라 한다

* 페이지 폴트시 -> 페이지 교체 정책 대표적인 3가지
  - 선입선출: 가장 오래된 페이지 교체
  - 최적 페이지 교체: 자주 사용될 예정인 페이지를 내버려두고 사용이 거의 안될 예정인 페이지를 교체, 실제로 구현하기 어려움 예상이 어려워서
  - LRU(Least Recently Used): 최근 사용빈도가 가장 적은것을 교체하는 것, 구현하기 쉽고 성능도 좋음

```python
# 선입선출 하나 만들어보기 운영체제라 생각하고
class PageReplacementFIFO:
    def __init__(self, capacity):
        self.capaciry = capacity
        self.pages = []

    def access_page(self, page) : # 4개째부터 교체가 이루어지게 하자
        if page not in self.pages : # 기존의 페이지에 없으면 집어넣자
            if len(self.pages) >= self.capacity:
                self.pages.pop(0) # 제일 앞에 있는 페이지 제거
            self.pages.append(page)
    def status(self):
        print("현재 페이지 상태 :", self.pages)

page_replacement = PageReplacementFIFO(capacity = 3)
page_replacement.status() # 빈상태 []
page_replacement.access_page(3)
page_replacement.status() # [3]
page_replacement.access_page(2)
page_replacement.status() # [3,2]
page_replacement.access_page(1)
page_replacement.status() # [3,2,1]

page_replacement.access_page(4)
page_replacement.status() # [2,1,4]

```

### 스래싱(thrashing)
> * 모든것의 근본적인 이유는 메모리 공간의 부족, 즉 프레임 부족 때문
> * 프레임이 부족하면 페이지 볼트가 자주 발생
> * 페이지 폴트가 발생하면 잦은 스와핑 작업으로 인해 CPU 사용률이 떨어지게 된다.
> * CPU 사용률이 떨어지면 운영체제는 더 많은 프로세스를 메모리에 올리려 하고, 이는 더 잦은 페이지 폴트로 이어져 악순환에 빠지게 된다.
> * 이러한 문제를 `스레싱`이라고 한다.

## 📌 스래싱(Thrashing) 개요
- **스래싱(Thrashing)**은 가상 메모리 시스템에서 **페이지 부재(Page Fault)**가 너무 자주 발생하여 **CPU가 메모리 스왑 처리에만 집중하고 실제 작업을 거의 수행하지 못하는 상태**를 의미함.
- 스래싱이 발생하면 **성능이 급격히 저하**되며, 시스템이 비효율적으로 동작함.

---

### 📌 스래싱 해결책
| **해결 방법** | **설명** |
|--------------|---------|
| **프레임 할당량 조정(Frame Allocation Adjustment)** | 프로세스가 사용하는 **물리 메모리 프레임 개수를 조절**하여 스래싱 방지 |
| **워킹셋(Working Set) 기법** | 프로세스가 일정 시간 동안 **자주 참조하는 페이지 집합(Working Set)을 유지**하여 성능 향상 |
| **페이지 부하 제어(Page Load Control)** | 한 번에 메모리에 올리는 페이지 수를 제한하여 **과부하 방지** |
| **PFF(Page Fault Frequency) 기법** | 페이지 부재(Page Fault) 발생 빈도를 기준으로 **프레임 수를 동적으로 조정** |
| **로컬 프레임 할당(Local Allocation) vs. 글로벌 할당(Global Allocation)** | **로컬 할당:** 프로세스마다 고정된 프레임 수 할당 <br> **글로벌 할당:** 모든 프로세스가 공유하는 프레임을 동적으로 할당 |
| **페이지 교체 알고리즘 최적화** | LRU(Least Recently Used), LFU(Least Frequently Used) 등의 효율적인 페이지 교체 알고리즘을 적용 |

---

### 📌 워킹셋(Working Set) 기법
#### **1. 개념**
- **워킹셋(Working Set)**이란 **프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합**을 의미함.
- 가상 메모리에서 프로세스가 일정 기간 내 참조한 페이지를 추적하여 **자주 사용하는 페이지를 메모리에 유지**하고, **사용하지 않는 페이지를 제거**함으로써 스래싱을 방지.

#### **2. 워킹셋의 정의**
- **W(Δ)**: 특정 시간 구간 **Δ(델타)** 동안 **프로세스가 참조한 페이지 집합**
- **Δ 값 선택이 중요**  
  - Δ 값이 너무 작으면 → 너무 많은 페이지가 제거됨 (과도한 페이지 부재)  
  - Δ 값이 너무 크면 → 불필요한 페이지까지 유지됨 (메모리 낭비)  

#### **3. 워킹셋을 활용한 스래싱 방지**
- 워킹셋을 유지하며 **최소한의 프레임을 확보**하여 스래싱을 방지.
- 일정 시간 동안 참조되지 않은 페이지는 **스왑 아웃(Swap Out)**하여 메모리 활용도를 높임.

#### **4. 워킹셋 기법의 장점**
✔ **스래싱 방지**: 자주 사용하는 페이지만 유지하여 CPU가 불필요한 스왑을 하지 않도록 함  
✔ **메모리 효율 증가**: 실제 필요한 페이지만 유지하므로 불필요한 페이지 사용 감소  
✔ **동적 프레임 조정 가능**: 프로세스의 실행 패턴에 따라 필요한 페이지를 동적으로 조절 가능  

---
