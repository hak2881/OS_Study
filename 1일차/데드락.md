
## 데드락(Deadlock)
> * 기다리는 대상이 꼬리에 꼬리를 물고 이어져서 아무도 작업을 진행하지 못하는 상황을 데드락이라 한다.
> * 공유자원으로 인해 발생

* 데드락 발생조건 4가지 중 모두 만족해야 발생 가능성이 생김
  1. 상호배제(Mutual exclusion) : 공유자원 같이 사용할 수 없어야 한다.
  2. 비선점(No preemption) : 공유자원을 가지고 있을때 빼았아서 사용할 수 없어야 한다
  3. 점유 및 대기(Hold and wait) : 쓰고있을 경우 사용하기 위해 기다리고 있어야 한다.
  4. **원형 대기(Circular waite)** : 꼬리에 꼬리를 물어 둥글게 형성되어 있어야 한다.

### 식사하는 철학자 문제

#### 📌 문제 개요
- **N명의 철학자**가 원형 테이블에 앉아 있음.
- 각 철학자는 **생각(Thinking)하거나 식사(Eating)** 함.
- **N개의 포크(Fork)**가 놓여 있으며, 각 철학자는 왼쪽과 오른쪽의 포크를 사용해야 식사할 수 있음.
- **문제:** 모든 철학자가 **교착 상태(Deadlock)나 기아 상태(Starvation)** 없이 원활하게 식사할 수 있도록 동기화해야 함.

#### 📌 문제 발생 가능성
- **경쟁 조건(Race Condition)**  
  - 여러 철학자가 동시에 포크를 집으려고 하면 **충돌**이 발생할 수 있음.  

- **교착 상태(Deadlock)**  
  - 모든 철학자가 **왼쪽 포크만 집고 오른쪽 포크를 기다리는 상황**이 발생하면 **영원히 대기**하게 됨.  

- **기아 상태(Starvation)**  
  - 일부 철학자가 계속해서 포크를 획득하지 못하면 **식사를 못하고 계속 굶는 상태**가 됨.

#### 📌 해결 방법
#####  **1. 순서 기반 해결법 (홀수-짝수 철학자)**
- **짝수 번호 철학자**: **왼쪽 → 오른쪽 포크 순서로 집음**  
- **홀수 번호 철학자**: **오른쪽 → 왼쪽 포크 순서로 집음**  
📌 **장점**: 교착 상태(Deadlock) 방지 가능

#####  **2. 웨이터(Butler) 알고리즘**
- **중앙 관리자(웨이터, Mutex)**가 철학자들에게 **최대 (N-1)개까지만 포크를 허용**  
- 철학자가 식사하려면 웨이터에게 **허가 요청**을 해야 함  
📌 **장점**: Deadlock 예방 및 자원 사용 관리 가능

#####  **3. 개별 철학자 스레드 + 세마포어**
- 각 철학자 스레드가 **세마포어(Semaphore)**를 사용하여 포크를 집도록 제한  
- **두 개의 세마포어**를 확보한 철학자만 식사 가능

#### 📌 파이썬 코드 예제 (Semaphore 사용)
```python
import threading
import time

N = 5  # 철학자 수
forks = [threading.Semaphore(1) for _ in range(N)]  # 포크 세마포어 배열

def philosopher(i):
    left = i
    right = (i + 1) % N

    while True:
        print(f"철학자 {i} 생각 중...")
        time.sleep(1)

        # 포크 집기
        forks[left].acquire()  # 왼쪽 포크 획득
        forks[right].acquire()  # 오른쪽 포크 획득

        print(f"🍽️ 철학자 {i} 식사 중...")
        time.sleep(2)

        # 포크 내려놓기
        forks[left].release()
        forks[right].release()

        print(f"철학자 {i} 식사 완료. 다시 생각 시작...")

# 철학자 스레드 생성 및 실행
threads = []
for i in range(N):
    t = threading.Thread(target=philosopher, args=(i,))
    threads.append(t)
    t.start()

# 모든 스레드가 종료될 때까지 대기
for t in threads:
    t.join()
```

#### 📌 코드 설명
1. **`threading.Semaphore(1)`**: 각 포크를 **이진 세마포어**로 설정 (한 번에 한 철학자만 사용 가능)  
2. **각 철학자는 왼쪽과 오른쪽 포크를 집고 식사**  
3. **식사가 끝나면 포크를 놓고 다시 생각 상태로 전환**  
4. **스레드 기반 실행**을 통해 병렬적으로 실행

#### 📌 해결된 문제점
* **Deadlock 방지**  
   - 두 개의 포크를 동시에 획득한 경우만 식사가 가능하여 **교착 상태 예방**  

* **Starvation 해결 가능**  
   - 웨이터 알고리즘 등 추가 적용 가능  

* **경쟁 조건 방지**  
   - `Semaphore.acquire()`를 사용하여 한 번에 하나의 철학자만 포크를 획득

#### 📌 결론
- **식사하는 철학자 문제는 동기화(Synchronization)의 대표적인 문제**  
- **세마포어, 웨이터 알고리즘 등을 활용하여 Deadlock과 Starvation을 방지 가능**  
- **멀티스레딩 환경에서 공유 자원(포크) 관리 방법을 학습하는 데 중요한 개념** 